<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><title>Python: package python2verilog</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head><body bgcolor="#f0f0f8">

<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="heading">
<tr bgcolor="#7799ee">
<td valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial">&nbsp;<br><big><big><strong>python2verilog</strong></big></big></font></td
><td align=right valign=bottom
><font color="#ffffff" face="helvetica, arial"><a href=".">index</a><br><a href="file:c%3A%5Cusers%5Ckerry%5Crepos%5Cp2v%5Cpython2verilog%5C__init__.py">c:\users\kerry\repos\p2v\python2verilog\__init__.py</a></font></td></tr></table>
    <p></p>
<p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#aa55cc">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Package Contents</strong></big></font></td></tr>
    
<tr><td bgcolor="#aa55cc"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><table width="100%" summary="list"><tr><td width="25%" valign=top><a href="python2verilog.generatorParser.html">generatorParser</a><br>
</td><td width="25%" valign=top><a href="python2verilog.generatorParserOld.html">generatorParserOld</a><br>
</td><td width="25%" valign=top><a href="python2verilog.utils.html">utils</a><br>
</td><td width="25%" valign=top><a href="python2verilog.verilogElements.html">verilogElements</a><br>
</td></tr></table></td></tr></table><p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ee77aa">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Classes</strong></big></font></td></tr>
    
<tr><td bgcolor="#ee77aa"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><dl>
<dt><font face="helvetica, arial"><a href="builtins.html#object">builtins.object</a>
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="python2verilog.generatorParser.html#GeneratorParser">python2verilog.generatorParser.GeneratorParser</a>
</font></dt><dt><font face="helvetica, arial"><a href="python2verilog.utils.html#Lines">python2verilog.utils.Lines</a>
</font></dt></dl>
</dd>
<dt><font face="helvetica, arial"><a href="builtins.html#str">builtins.str</a>(<a href="builtins.html#object">builtins.object</a>)
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="python2verilog.utils.html#IStr">python2verilog.utils.IStr</a>
</font></dt></dl>
</dd>
</dl>
 <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="GeneratorParser">class <strong>GeneratorParser</strong></a>(<a href="builtins.html#object">builtins.object</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#GeneratorParser">GeneratorParser</a>(root:&nbsp;'ast.FunctionDef')<br>
&nbsp;<br>
Parses&nbsp;python&nbsp;generator&nbsp;functions<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="GeneratorParser-__init__"><strong>__init__</strong></a>(self, root: 'ast.FunctionDef')</dt><dd><tt>Initializes&nbsp;the&nbsp;parser,&nbsp;does&nbsp;quick&nbsp;setup&nbsp;work</tt></dd></dl>

<dl><dt><a name="GeneratorParser-add_global_var"><strong>add_global_var</strong></a>(self, initial_value: 'str', name: 'str')</dt><dd><tt>Adds&nbsp;global&nbsp;variables</tt></dd></dl>

<dl><dt><a name="GeneratorParser-create_unique_name"><strong>create_unique_name</strong></a>(self)</dt><dd><tt>Generates&nbsp;an&nbsp;id&nbsp;that&nbsp;is&nbsp;unique&nbsp;among&nbsp;all&nbsp;unique&nbsp;global&nbsp;variables</tt></dd></dl>

<dl><dt><a name="GeneratorParser-generate_verilog"><strong>generate_verilog</strong></a>(self, indent: 'int' = 0)</dt><dd><tt>Generates&nbsp;the&nbsp;verilog&nbsp;(does&nbsp;the&nbsp;most&nbsp;work,&nbsp;calls&nbsp;other&nbsp;functions)</tt></dd></dl>

<dl><dt><a name="GeneratorParser-parse_for"><strong>parse_for</strong></a>(self, node: 'ast.For', prefix: 'str' = '')</dt><dd><tt>Creates&nbsp;a&nbsp;conditional&nbsp;while&nbsp;loop&nbsp;from&nbsp;for&nbsp;loop</tt></dd></dl>

<dl><dt><a name="GeneratorParser-parse_statement"><strong>parse_statement</strong></a>(self, stmt: 'ast.AST', prefix: 'str' = '')</dt><dd><tt>&lt;statement&gt;&nbsp;(e.g.&nbsp;assign,&nbsp;for&nbsp;loop,&nbsp;etc.,&nbsp;those&nbsp;that&nbsp;do&nbsp;not&nbsp;return&nbsp;a&nbsp;value)</tt></dd></dl>

<dl><dt><a name="GeneratorParser-parse_statements"><strong>parse_statements</strong></a>(self, stmts: 'list[ast.AST]', prefix: 'str', endStatements: 'Lines' = , resetToZero: 'bool' = False)</dt><dd><tt>Warning:&nbsp;mutates&nbsp;global_vars<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;statement0&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;statement1&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;...<br>
}</tt></dd></dl>

<dl><dt><a name="GeneratorParser-parse_subscript"><strong>parse_subscript</strong></a>(self, node: 'ast.Subscript', indent: 'int' = 0)</dt><dd><tt>&lt;value&gt;[&lt;slice&gt;]<br>
Note:&nbsp;built&nbsp;from&nbsp;right&nbsp;to&nbsp;left,&nbsp;e.g.&nbsp;[z]&nbsp;-&gt;&nbsp;[y][z]&nbsp;-&gt;&nbsp;[x][y][z]&nbsp;-&gt;&nbsp;matrix[x][y][z]</tt></dd></dl>

<dl><dt><a name="GeneratorParser-parse_yield"><strong>parse_yield</strong></a>(self, node: 'ast.Yield')</dt><dd><tt>Warning:&nbsp;may&nbsp;not&nbsp;work&nbsp;for&nbsp;single&nbsp;output<br>
&nbsp;<br>
Warning:&nbsp;requires&nbsp;self.<strong>yieldVars</strong>&nbsp;to&nbsp;be&nbsp;complete<br>
&nbsp;<br>
yield&nbsp;&lt;value&gt;;</tt></dd></dl>

<dl><dt><a name="GeneratorParser-stringify_module"><strong>stringify_module</strong></a>(self) -&gt; 'tuple[Lines, Lines]'</dt><dd><tt>module&nbsp;&lt;name&gt;(...);<br>
&nbsp;<br>
endmodule</tt></dd></dl>

<hr>
Static methods defined here:<br>
<dl><dt><a name="GeneratorParser-generate_return_vars"><strong>generate_return_vars</strong></a>(node: 'ast.AST', prefix: 'str')</dt><dd><tt>Generates&nbsp;the&nbsp;yielded&nbsp;variables&nbsp;of&nbsp;the&nbsp;function</tt></dd></dl>

<dl><dt><a name="GeneratorParser-parse_assign"><strong>parse_assign</strong></a>(node: 'ast.Assign')</dt><dd><tt>&lt;target0,&nbsp;target1,&nbsp;...&gt;&nbsp;=&nbsp;&lt;value&gt;;</tt></dd></dl>

<dl><dt><a name="GeneratorParser-parse_binop"><strong>parse_binop</strong></a>(node: 'ast.BinOp')</dt><dd><tt>&lt;left&gt;&nbsp;&lt;op&gt;&nbsp;&lt;right&gt;</tt></dd></dl>

<dl><dt><a name="GeneratorParser-parse_expression"><strong>parse_expression</strong></a>(expr: 'ast.AST', indent: 'int' = 0)</dt><dd><tt>&lt;expression&gt;&nbsp;(e.g.&nbsp;constant,&nbsp;name,&nbsp;subscript,&nbsp;etc.,&nbsp;those&nbsp;that&nbsp;return&nbsp;a&nbsp;value)</tt></dd></dl>

<dl><dt><a name="GeneratorParser-parse_targets"><strong>parse_targets</strong></a>(nodes: 'list[ast.AST]')</dt><dd><tt>Warning:&nbsp;only&nbsp;single&nbsp;target&nbsp;on&nbsp;left-hand-side&nbsp;supported<br>
&nbsp;<br>
&lt;target0,&nbsp;target1,&nbsp;...&gt;&nbsp;=</tt></dd></dl>

<dl><dt><a name="GeneratorParser-stringify_always_block"><strong>stringify_always_block</strong></a>()</dt><dd><tt>always&nbsp;@(posedge&nbsp;_clock)&nbsp;begin<br>
end</tt></dd></dl>

<dl><dt><a name="GeneratorParser-stringify_declarations"><strong>stringify_declarations</strong></a>(global_vars: 'dict[str, str]') -&gt; 'tuple[Lines, Lines]'</dt><dd><tt>reg&nbsp;[31:0]&nbsp;&lt;name&gt;;<br>
...</tt></dd></dl>

<dl><dt><a name="GeneratorParser-stringify_initialization"><strong>stringify_initialization</strong></a>(global_vars: 'dict[str, str]')</dt><dd><tt>if&nbsp;(_start)&nbsp;begin<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;var&gt;&nbsp;=&nbsp;&lt;value&gt;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;...<br>
end&nbsp;else&nbsp;begin<br>
...<br>
end</tt></dd></dl>

<hr>
Data descriptors defined here:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="IStr">class <strong>IStr</strong></a>(<a href="builtins.html#str">builtins.str</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>String&nbsp;with&nbsp;with&nbsp;&gt;&gt;&nbsp;operator&nbsp;for&nbsp;indenting<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="python2verilog.utils.html#IStr">IStr</a></dd>
<dd><a href="builtins.html#str">builtins.str</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="IStr-__rshift__"><strong>__rshift__</strong></a>(self, other: 'int') -&gt; 'str'</dt></dl>

<hr>
Data descriptors defined here:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Methods inherited from <a href="builtins.html#str">builtins.str</a>:<br>
<dl><dt><a name="IStr-__add__"><strong>__add__</strong></a>(self, value, /)</dt><dd><tt>Return&nbsp;self+value.</tt></dd></dl>

<dl><dt><a name="IStr-__contains__"><strong>__contains__</strong></a>(self, key, /)</dt><dd><tt>Return&nbsp;key&nbsp;in&nbsp;self.</tt></dd></dl>

<dl><dt><a name="IStr-__eq__"><strong>__eq__</strong></a>(self, value, /)</dt><dd><tt>Return&nbsp;self==value.</tt></dd></dl>

<dl><dt><a name="IStr-__format__"><strong>__format__</strong></a>(self, format_spec, /)</dt><dd><tt>Return&nbsp;a&nbsp;formatted&nbsp;version&nbsp;of&nbsp;the&nbsp;string&nbsp;as&nbsp;described&nbsp;by&nbsp;format_spec.</tt></dd></dl>

<dl><dt><a name="IStr-__ge__"><strong>__ge__</strong></a>(self, value, /)</dt><dd><tt>Return&nbsp;self&gt;=value.</tt></dd></dl>

<dl><dt><a name="IStr-__getattribute__"><strong>__getattribute__</strong></a>(self, name, /)</dt><dd><tt>Return&nbsp;getattr(self,&nbsp;name).</tt></dd></dl>

<dl><dt><a name="IStr-__getitem__"><strong>__getitem__</strong></a>(self, key, /)</dt><dd><tt>Return&nbsp;self[key].</tt></dd></dl>

<dl><dt><a name="IStr-__getnewargs__"><strong>__getnewargs__</strong></a>(...)</dt></dl>

<dl><dt><a name="IStr-__gt__"><strong>__gt__</strong></a>(self, value, /)</dt><dd><tt>Return&nbsp;self&gt;value.</tt></dd></dl>

<dl><dt><a name="IStr-__hash__"><strong>__hash__</strong></a>(self, /)</dt><dd><tt>Return&nbsp;hash(self).</tt></dd></dl>

<dl><dt><a name="IStr-__iter__"><strong>__iter__</strong></a>(self, /)</dt><dd><tt>Implement&nbsp;iter(self).</tt></dd></dl>

<dl><dt><a name="IStr-__le__"><strong>__le__</strong></a>(self, value, /)</dt><dd><tt>Return&nbsp;self&lt;=value.</tt></dd></dl>

<dl><dt><a name="IStr-__len__"><strong>__len__</strong></a>(self, /)</dt><dd><tt>Return&nbsp;len(self).</tt></dd></dl>

<dl><dt><a name="IStr-__lt__"><strong>__lt__</strong></a>(self, value, /)</dt><dd><tt>Return&nbsp;self&lt;value.</tt></dd></dl>

<dl><dt><a name="IStr-__mod__"><strong>__mod__</strong></a>(self, value, /)</dt><dd><tt>Return&nbsp;self%value.</tt></dd></dl>

<dl><dt><a name="IStr-__mul__"><strong>__mul__</strong></a>(self, value, /)</dt><dd><tt>Return&nbsp;self*value.</tt></dd></dl>

<dl><dt><a name="IStr-__ne__"><strong>__ne__</strong></a>(self, value, /)</dt><dd><tt>Return&nbsp;self!=value.</tt></dd></dl>

<dl><dt><a name="IStr-__repr__"><strong>__repr__</strong></a>(self, /)</dt><dd><tt>Return&nbsp;repr(self).</tt></dd></dl>

<dl><dt><a name="IStr-__rmod__"><strong>__rmod__</strong></a>(self, value, /)</dt><dd><tt>Return&nbsp;value%self.</tt></dd></dl>

<dl><dt><a name="IStr-__rmul__"><strong>__rmul__</strong></a>(self, value, /)</dt><dd><tt>Return&nbsp;value*self.</tt></dd></dl>

<dl><dt><a name="IStr-__sizeof__"><strong>__sizeof__</strong></a>(self, /)</dt><dd><tt>Return&nbsp;the&nbsp;size&nbsp;of&nbsp;the&nbsp;string&nbsp;in&nbsp;memory,&nbsp;in&nbsp;bytes.</tt></dd></dl>

<dl><dt><a name="IStr-__str__"><strong>__str__</strong></a>(self, /)</dt><dd><tt>Return&nbsp;<a href="builtins.html#str">str</a>(self).</tt></dd></dl>

<dl><dt><a name="IStr-capitalize"><strong>capitalize</strong></a>(self, /)</dt><dd><tt>Return&nbsp;a&nbsp;capitalized&nbsp;version&nbsp;of&nbsp;the&nbsp;string.<br>
&nbsp;<br>
More&nbsp;specifically,&nbsp;make&nbsp;the&nbsp;first&nbsp;character&nbsp;have&nbsp;upper&nbsp;case&nbsp;and&nbsp;the&nbsp;rest&nbsp;lower<br>
case.</tt></dd></dl>

<dl><dt><a name="IStr-casefold"><strong>casefold</strong></a>(self, /)</dt><dd><tt>Return&nbsp;a&nbsp;version&nbsp;of&nbsp;the&nbsp;string&nbsp;suitable&nbsp;for&nbsp;caseless&nbsp;comparisons.</tt></dd></dl>

<dl><dt><a name="IStr-center"><strong>center</strong></a>(self, width, fillchar=' ', /)</dt><dd><tt>Return&nbsp;a&nbsp;centered&nbsp;string&nbsp;of&nbsp;length&nbsp;width.<br>
&nbsp;<br>
Padding&nbsp;is&nbsp;done&nbsp;using&nbsp;the&nbsp;specified&nbsp;fill&nbsp;character&nbsp;(default&nbsp;is&nbsp;a&nbsp;space).</tt></dd></dl>

<dl><dt><a name="IStr-count"><strong>count</strong></a>(...)</dt><dd><tt>S.<a href="#IStr-count">count</a>(sub[,&nbsp;start[,&nbsp;end]])&nbsp;-&gt;&nbsp;int<br>
&nbsp;<br>
Return&nbsp;the&nbsp;number&nbsp;of&nbsp;non-overlapping&nbsp;occurrences&nbsp;of&nbsp;substring&nbsp;sub&nbsp;in<br>
string&nbsp;S[start:end].&nbsp;&nbsp;Optional&nbsp;arguments&nbsp;start&nbsp;and&nbsp;end&nbsp;are<br>
interpreted&nbsp;as&nbsp;in&nbsp;slice&nbsp;notation.</tt></dd></dl>

<dl><dt><a name="IStr-encode"><strong>encode</strong></a>(self, /, encoding='utf-8', errors='strict')</dt><dd><tt>Encode&nbsp;the&nbsp;string&nbsp;using&nbsp;the&nbsp;codec&nbsp;registered&nbsp;for&nbsp;encoding.<br>
&nbsp;<br>
encoding<br>
&nbsp;&nbsp;The&nbsp;encoding&nbsp;in&nbsp;which&nbsp;to&nbsp;encode&nbsp;the&nbsp;string.<br>
errors<br>
&nbsp;&nbsp;The&nbsp;error&nbsp;handling&nbsp;scheme&nbsp;to&nbsp;use&nbsp;for&nbsp;encoding&nbsp;errors.<br>
&nbsp;&nbsp;The&nbsp;default&nbsp;is&nbsp;'strict'&nbsp;meaning&nbsp;that&nbsp;encoding&nbsp;errors&nbsp;raise&nbsp;a<br>
&nbsp;&nbsp;UnicodeEncodeError.&nbsp;&nbsp;Other&nbsp;possible&nbsp;values&nbsp;are&nbsp;'ignore',&nbsp;'replace'&nbsp;and<br>
&nbsp;&nbsp;'xmlcharrefreplace'&nbsp;as&nbsp;well&nbsp;as&nbsp;any&nbsp;other&nbsp;name&nbsp;registered&nbsp;with<br>
&nbsp;&nbsp;codecs.register_error&nbsp;that&nbsp;can&nbsp;handle&nbsp;UnicodeEncodeErrors.</tt></dd></dl>

<dl><dt><a name="IStr-endswith"><strong>endswith</strong></a>(...)</dt><dd><tt>S.<a href="#IStr-endswith">endswith</a>(suffix[,&nbsp;start[,&nbsp;end]])&nbsp;-&gt;&nbsp;bool<br>
&nbsp;<br>
Return&nbsp;True&nbsp;if&nbsp;S&nbsp;ends&nbsp;with&nbsp;the&nbsp;specified&nbsp;suffix,&nbsp;False&nbsp;otherwise.<br>
With&nbsp;optional&nbsp;start,&nbsp;test&nbsp;S&nbsp;beginning&nbsp;at&nbsp;that&nbsp;position.<br>
With&nbsp;optional&nbsp;end,&nbsp;stop&nbsp;comparing&nbsp;S&nbsp;at&nbsp;that&nbsp;position.<br>
suffix&nbsp;can&nbsp;also&nbsp;be&nbsp;a&nbsp;tuple&nbsp;of&nbsp;strings&nbsp;to&nbsp;try.</tt></dd></dl>

<dl><dt><a name="IStr-expandtabs"><strong>expandtabs</strong></a>(self, /, tabsize=8)</dt><dd><tt>Return&nbsp;a&nbsp;copy&nbsp;where&nbsp;all&nbsp;tab&nbsp;characters&nbsp;are&nbsp;expanded&nbsp;using&nbsp;spaces.<br>
&nbsp;<br>
If&nbsp;tabsize&nbsp;is&nbsp;not&nbsp;given,&nbsp;a&nbsp;tab&nbsp;size&nbsp;of&nbsp;8&nbsp;characters&nbsp;is&nbsp;assumed.</tt></dd></dl>

<dl><dt><a name="IStr-find"><strong>find</strong></a>(...)</dt><dd><tt>S.<a href="#IStr-find">find</a>(sub[,&nbsp;start[,&nbsp;end]])&nbsp;-&gt;&nbsp;int<br>
&nbsp;<br>
Return&nbsp;the&nbsp;lowest&nbsp;index&nbsp;in&nbsp;S&nbsp;where&nbsp;substring&nbsp;sub&nbsp;is&nbsp;found,<br>
such&nbsp;that&nbsp;sub&nbsp;is&nbsp;contained&nbsp;within&nbsp;S[start:end].&nbsp;&nbsp;Optional<br>
arguments&nbsp;start&nbsp;and&nbsp;end&nbsp;are&nbsp;interpreted&nbsp;as&nbsp;in&nbsp;slice&nbsp;notation.<br>
&nbsp;<br>
Return&nbsp;-1&nbsp;on&nbsp;failure.</tt></dd></dl>

<dl><dt><a name="IStr-format"><strong>format</strong></a>(...)</dt><dd><tt>S.<a href="#IStr-format">format</a>(*args,&nbsp;**kwargs)&nbsp;-&gt;&nbsp;<a href="builtins.html#str">str</a><br>
&nbsp;<br>
Return&nbsp;a&nbsp;formatted&nbsp;version&nbsp;of&nbsp;S,&nbsp;using&nbsp;substitutions&nbsp;from&nbsp;args&nbsp;and&nbsp;kwargs.<br>
The&nbsp;substitutions&nbsp;are&nbsp;identified&nbsp;by&nbsp;braces&nbsp;('{'&nbsp;and&nbsp;'}').</tt></dd></dl>

<dl><dt><a name="IStr-format_map"><strong>format_map</strong></a>(...)</dt><dd><tt>S.<a href="#IStr-format_map">format_map</a>(mapping)&nbsp;-&gt;&nbsp;<a href="builtins.html#str">str</a><br>
&nbsp;<br>
Return&nbsp;a&nbsp;formatted&nbsp;version&nbsp;of&nbsp;S,&nbsp;using&nbsp;substitutions&nbsp;from&nbsp;mapping.<br>
The&nbsp;substitutions&nbsp;are&nbsp;identified&nbsp;by&nbsp;braces&nbsp;('{'&nbsp;and&nbsp;'}').</tt></dd></dl>

<dl><dt><a name="IStr-index"><strong>index</strong></a>(...)</dt><dd><tt>S.<a href="#IStr-index">index</a>(sub[,&nbsp;start[,&nbsp;end]])&nbsp;-&gt;&nbsp;int<br>
&nbsp;<br>
Return&nbsp;the&nbsp;lowest&nbsp;index&nbsp;in&nbsp;S&nbsp;where&nbsp;substring&nbsp;sub&nbsp;is&nbsp;found,<br>
such&nbsp;that&nbsp;sub&nbsp;is&nbsp;contained&nbsp;within&nbsp;S[start:end].&nbsp;&nbsp;Optional<br>
arguments&nbsp;start&nbsp;and&nbsp;end&nbsp;are&nbsp;interpreted&nbsp;as&nbsp;in&nbsp;slice&nbsp;notation.<br>
&nbsp;<br>
Raises&nbsp;ValueError&nbsp;when&nbsp;the&nbsp;substring&nbsp;is&nbsp;not&nbsp;found.</tt></dd></dl>

<dl><dt><a name="IStr-isalnum"><strong>isalnum</strong></a>(self, /)</dt><dd><tt>Return&nbsp;True&nbsp;if&nbsp;the&nbsp;string&nbsp;is&nbsp;an&nbsp;alpha-numeric&nbsp;string,&nbsp;False&nbsp;otherwise.<br>
&nbsp;<br>
A&nbsp;string&nbsp;is&nbsp;alpha-numeric&nbsp;if&nbsp;all&nbsp;characters&nbsp;in&nbsp;the&nbsp;string&nbsp;are&nbsp;alpha-numeric&nbsp;and<br>
there&nbsp;is&nbsp;at&nbsp;least&nbsp;one&nbsp;character&nbsp;in&nbsp;the&nbsp;string.</tt></dd></dl>

<dl><dt><a name="IStr-isalpha"><strong>isalpha</strong></a>(self, /)</dt><dd><tt>Return&nbsp;True&nbsp;if&nbsp;the&nbsp;string&nbsp;is&nbsp;an&nbsp;alphabetic&nbsp;string,&nbsp;False&nbsp;otherwise.<br>
&nbsp;<br>
A&nbsp;string&nbsp;is&nbsp;alphabetic&nbsp;if&nbsp;all&nbsp;characters&nbsp;in&nbsp;the&nbsp;string&nbsp;are&nbsp;alphabetic&nbsp;and&nbsp;there<br>
is&nbsp;at&nbsp;least&nbsp;one&nbsp;character&nbsp;in&nbsp;the&nbsp;string.</tt></dd></dl>

<dl><dt><a name="IStr-isascii"><strong>isascii</strong></a>(self, /)</dt><dd><tt>Return&nbsp;True&nbsp;if&nbsp;all&nbsp;characters&nbsp;in&nbsp;the&nbsp;string&nbsp;are&nbsp;ASCII,&nbsp;False&nbsp;otherwise.<br>
&nbsp;<br>
ASCII&nbsp;characters&nbsp;have&nbsp;code&nbsp;points&nbsp;in&nbsp;the&nbsp;range&nbsp;U+0000-U+007F.<br>
Empty&nbsp;string&nbsp;is&nbsp;ASCII&nbsp;too.</tt></dd></dl>

<dl><dt><a name="IStr-isdecimal"><strong>isdecimal</strong></a>(self, /)</dt><dd><tt>Return&nbsp;True&nbsp;if&nbsp;the&nbsp;string&nbsp;is&nbsp;a&nbsp;decimal&nbsp;string,&nbsp;False&nbsp;otherwise.<br>
&nbsp;<br>
A&nbsp;string&nbsp;is&nbsp;a&nbsp;decimal&nbsp;string&nbsp;if&nbsp;all&nbsp;characters&nbsp;in&nbsp;the&nbsp;string&nbsp;are&nbsp;decimal&nbsp;and<br>
there&nbsp;is&nbsp;at&nbsp;least&nbsp;one&nbsp;character&nbsp;in&nbsp;the&nbsp;string.</tt></dd></dl>

<dl><dt><a name="IStr-isdigit"><strong>isdigit</strong></a>(self, /)</dt><dd><tt>Return&nbsp;True&nbsp;if&nbsp;the&nbsp;string&nbsp;is&nbsp;a&nbsp;digit&nbsp;string,&nbsp;False&nbsp;otherwise.<br>
&nbsp;<br>
A&nbsp;string&nbsp;is&nbsp;a&nbsp;digit&nbsp;string&nbsp;if&nbsp;all&nbsp;characters&nbsp;in&nbsp;the&nbsp;string&nbsp;are&nbsp;digits&nbsp;and&nbsp;there<br>
is&nbsp;at&nbsp;least&nbsp;one&nbsp;character&nbsp;in&nbsp;the&nbsp;string.</tt></dd></dl>

<dl><dt><a name="IStr-isidentifier"><strong>isidentifier</strong></a>(self, /)</dt><dd><tt>Return&nbsp;True&nbsp;if&nbsp;the&nbsp;string&nbsp;is&nbsp;a&nbsp;valid&nbsp;Python&nbsp;identifier,&nbsp;False&nbsp;otherwise.<br>
&nbsp;<br>
Call&nbsp;keyword.iskeyword(s)&nbsp;to&nbsp;test&nbsp;whether&nbsp;string&nbsp;s&nbsp;is&nbsp;a&nbsp;reserved&nbsp;identifier,<br>
such&nbsp;as&nbsp;"def"&nbsp;or&nbsp;"class".</tt></dd></dl>

<dl><dt><a name="IStr-islower"><strong>islower</strong></a>(self, /)</dt><dd><tt>Return&nbsp;True&nbsp;if&nbsp;the&nbsp;string&nbsp;is&nbsp;a&nbsp;lowercase&nbsp;string,&nbsp;False&nbsp;otherwise.<br>
&nbsp;<br>
A&nbsp;string&nbsp;is&nbsp;lowercase&nbsp;if&nbsp;all&nbsp;cased&nbsp;characters&nbsp;in&nbsp;the&nbsp;string&nbsp;are&nbsp;lowercase&nbsp;and<br>
there&nbsp;is&nbsp;at&nbsp;least&nbsp;one&nbsp;cased&nbsp;character&nbsp;in&nbsp;the&nbsp;string.</tt></dd></dl>

<dl><dt><a name="IStr-isnumeric"><strong>isnumeric</strong></a>(self, /)</dt><dd><tt>Return&nbsp;True&nbsp;if&nbsp;the&nbsp;string&nbsp;is&nbsp;a&nbsp;numeric&nbsp;string,&nbsp;False&nbsp;otherwise.<br>
&nbsp;<br>
A&nbsp;string&nbsp;is&nbsp;numeric&nbsp;if&nbsp;all&nbsp;characters&nbsp;in&nbsp;the&nbsp;string&nbsp;are&nbsp;numeric&nbsp;and&nbsp;there&nbsp;is&nbsp;at<br>
least&nbsp;one&nbsp;character&nbsp;in&nbsp;the&nbsp;string.</tt></dd></dl>

<dl><dt><a name="IStr-isprintable"><strong>isprintable</strong></a>(self, /)</dt><dd><tt>Return&nbsp;True&nbsp;if&nbsp;the&nbsp;string&nbsp;is&nbsp;printable,&nbsp;False&nbsp;otherwise.<br>
&nbsp;<br>
A&nbsp;string&nbsp;is&nbsp;printable&nbsp;if&nbsp;all&nbsp;of&nbsp;its&nbsp;characters&nbsp;are&nbsp;considered&nbsp;printable&nbsp;in<br>
repr()&nbsp;or&nbsp;if&nbsp;it&nbsp;is&nbsp;empty.</tt></dd></dl>

<dl><dt><a name="IStr-isspace"><strong>isspace</strong></a>(self, /)</dt><dd><tt>Return&nbsp;True&nbsp;if&nbsp;the&nbsp;string&nbsp;is&nbsp;a&nbsp;whitespace&nbsp;string,&nbsp;False&nbsp;otherwise.<br>
&nbsp;<br>
A&nbsp;string&nbsp;is&nbsp;whitespace&nbsp;if&nbsp;all&nbsp;characters&nbsp;in&nbsp;the&nbsp;string&nbsp;are&nbsp;whitespace&nbsp;and&nbsp;there<br>
is&nbsp;at&nbsp;least&nbsp;one&nbsp;character&nbsp;in&nbsp;the&nbsp;string.</tt></dd></dl>

<dl><dt><a name="IStr-istitle"><strong>istitle</strong></a>(self, /)</dt><dd><tt>Return&nbsp;True&nbsp;if&nbsp;the&nbsp;string&nbsp;is&nbsp;a&nbsp;title-cased&nbsp;string,&nbsp;False&nbsp;otherwise.<br>
&nbsp;<br>
In&nbsp;a&nbsp;title-cased&nbsp;string,&nbsp;upper-&nbsp;and&nbsp;title-case&nbsp;characters&nbsp;may&nbsp;only<br>
follow&nbsp;uncased&nbsp;characters&nbsp;and&nbsp;lowercase&nbsp;characters&nbsp;only&nbsp;cased&nbsp;ones.</tt></dd></dl>

<dl><dt><a name="IStr-isupper"><strong>isupper</strong></a>(self, /)</dt><dd><tt>Return&nbsp;True&nbsp;if&nbsp;the&nbsp;string&nbsp;is&nbsp;an&nbsp;uppercase&nbsp;string,&nbsp;False&nbsp;otherwise.<br>
&nbsp;<br>
A&nbsp;string&nbsp;is&nbsp;uppercase&nbsp;if&nbsp;all&nbsp;cased&nbsp;characters&nbsp;in&nbsp;the&nbsp;string&nbsp;are&nbsp;uppercase&nbsp;and<br>
there&nbsp;is&nbsp;at&nbsp;least&nbsp;one&nbsp;cased&nbsp;character&nbsp;in&nbsp;the&nbsp;string.</tt></dd></dl>

<dl><dt><a name="IStr-join"><strong>join</strong></a>(self, iterable, /)</dt><dd><tt>Concatenate&nbsp;any&nbsp;number&nbsp;of&nbsp;strings.<br>
&nbsp;<br>
The&nbsp;string&nbsp;whose&nbsp;method&nbsp;is&nbsp;called&nbsp;is&nbsp;inserted&nbsp;in&nbsp;between&nbsp;each&nbsp;given&nbsp;string.<br>
The&nbsp;result&nbsp;is&nbsp;returned&nbsp;as&nbsp;a&nbsp;new&nbsp;string.<br>
&nbsp;<br>
Example:&nbsp;'.'.<a href="#IStr-join">join</a>(['ab',&nbsp;'pq',&nbsp;'rs'])&nbsp;-&gt;&nbsp;'ab.pq.rs'</tt></dd></dl>

<dl><dt><a name="IStr-ljust"><strong>ljust</strong></a>(self, width, fillchar=' ', /)</dt><dd><tt>Return&nbsp;a&nbsp;left-justified&nbsp;string&nbsp;of&nbsp;length&nbsp;width.<br>
&nbsp;<br>
Padding&nbsp;is&nbsp;done&nbsp;using&nbsp;the&nbsp;specified&nbsp;fill&nbsp;character&nbsp;(default&nbsp;is&nbsp;a&nbsp;space).</tt></dd></dl>

<dl><dt><a name="IStr-lower"><strong>lower</strong></a>(self, /)</dt><dd><tt>Return&nbsp;a&nbsp;copy&nbsp;of&nbsp;the&nbsp;string&nbsp;converted&nbsp;to&nbsp;lowercase.</tt></dd></dl>

<dl><dt><a name="IStr-lstrip"><strong>lstrip</strong></a>(self, chars=None, /)</dt><dd><tt>Return&nbsp;a&nbsp;copy&nbsp;of&nbsp;the&nbsp;string&nbsp;with&nbsp;leading&nbsp;whitespace&nbsp;removed.<br>
&nbsp;<br>
If&nbsp;chars&nbsp;is&nbsp;given&nbsp;and&nbsp;not&nbsp;None,&nbsp;remove&nbsp;characters&nbsp;in&nbsp;chars&nbsp;instead.</tt></dd></dl>

<dl><dt><a name="IStr-partition"><strong>partition</strong></a>(self, sep, /)</dt><dd><tt>Partition&nbsp;the&nbsp;string&nbsp;into&nbsp;three&nbsp;parts&nbsp;using&nbsp;the&nbsp;given&nbsp;separator.<br>
&nbsp;<br>
This&nbsp;will&nbsp;search&nbsp;for&nbsp;the&nbsp;separator&nbsp;in&nbsp;the&nbsp;string.&nbsp;&nbsp;If&nbsp;the&nbsp;separator&nbsp;is&nbsp;found,<br>
returns&nbsp;a&nbsp;3-tuple&nbsp;containing&nbsp;the&nbsp;part&nbsp;before&nbsp;the&nbsp;separator,&nbsp;the&nbsp;separator<br>
itself,&nbsp;and&nbsp;the&nbsp;part&nbsp;after&nbsp;it.<br>
&nbsp;<br>
If&nbsp;the&nbsp;separator&nbsp;is&nbsp;not&nbsp;found,&nbsp;returns&nbsp;a&nbsp;3-tuple&nbsp;containing&nbsp;the&nbsp;original&nbsp;string<br>
and&nbsp;two&nbsp;empty&nbsp;strings.</tt></dd></dl>

<dl><dt><a name="IStr-removeprefix"><strong>removeprefix</strong></a>(self, prefix, /)</dt><dd><tt>Return&nbsp;a&nbsp;<a href="builtins.html#str">str</a>&nbsp;with&nbsp;the&nbsp;given&nbsp;prefix&nbsp;string&nbsp;removed&nbsp;if&nbsp;present.<br>
&nbsp;<br>
If&nbsp;the&nbsp;string&nbsp;starts&nbsp;with&nbsp;the&nbsp;prefix&nbsp;string,&nbsp;return&nbsp;string[len(prefix):].<br>
Otherwise,&nbsp;return&nbsp;a&nbsp;copy&nbsp;of&nbsp;the&nbsp;original&nbsp;string.</tt></dd></dl>

<dl><dt><a name="IStr-removesuffix"><strong>removesuffix</strong></a>(self, suffix, /)</dt><dd><tt>Return&nbsp;a&nbsp;<a href="builtins.html#str">str</a>&nbsp;with&nbsp;the&nbsp;given&nbsp;suffix&nbsp;string&nbsp;removed&nbsp;if&nbsp;present.<br>
&nbsp;<br>
If&nbsp;the&nbsp;string&nbsp;ends&nbsp;with&nbsp;the&nbsp;suffix&nbsp;string&nbsp;and&nbsp;that&nbsp;suffix&nbsp;is&nbsp;not&nbsp;empty,<br>
return&nbsp;string[:-len(suffix)].&nbsp;Otherwise,&nbsp;return&nbsp;a&nbsp;copy&nbsp;of&nbsp;the&nbsp;original<br>
string.</tt></dd></dl>

<dl><dt><a name="IStr-replace"><strong>replace</strong></a>(self, old, new, count=-1, /)</dt><dd><tt>Return&nbsp;a&nbsp;copy&nbsp;with&nbsp;all&nbsp;occurrences&nbsp;of&nbsp;substring&nbsp;old&nbsp;replaced&nbsp;by&nbsp;new.<br>
&nbsp;<br>
&nbsp;&nbsp;count<br>
&nbsp;&nbsp;&nbsp;&nbsp;Maximum&nbsp;number&nbsp;of&nbsp;occurrences&nbsp;to&nbsp;replace.<br>
&nbsp;&nbsp;&nbsp;&nbsp;-1&nbsp;(the&nbsp;default&nbsp;value)&nbsp;means&nbsp;replace&nbsp;all&nbsp;occurrences.<br>
&nbsp;<br>
If&nbsp;the&nbsp;optional&nbsp;argument&nbsp;count&nbsp;is&nbsp;given,&nbsp;only&nbsp;the&nbsp;first&nbsp;count&nbsp;occurrences&nbsp;are<br>
replaced.</tt></dd></dl>

<dl><dt><a name="IStr-rfind"><strong>rfind</strong></a>(...)</dt><dd><tt>S.<a href="#IStr-rfind">rfind</a>(sub[,&nbsp;start[,&nbsp;end]])&nbsp;-&gt;&nbsp;int<br>
&nbsp;<br>
Return&nbsp;the&nbsp;highest&nbsp;index&nbsp;in&nbsp;S&nbsp;where&nbsp;substring&nbsp;sub&nbsp;is&nbsp;found,<br>
such&nbsp;that&nbsp;sub&nbsp;is&nbsp;contained&nbsp;within&nbsp;S[start:end].&nbsp;&nbsp;Optional<br>
arguments&nbsp;start&nbsp;and&nbsp;end&nbsp;are&nbsp;interpreted&nbsp;as&nbsp;in&nbsp;slice&nbsp;notation.<br>
&nbsp;<br>
Return&nbsp;-1&nbsp;on&nbsp;failure.</tt></dd></dl>

<dl><dt><a name="IStr-rindex"><strong>rindex</strong></a>(...)</dt><dd><tt>S.<a href="#IStr-rindex">rindex</a>(sub[,&nbsp;start[,&nbsp;end]])&nbsp;-&gt;&nbsp;int<br>
&nbsp;<br>
Return&nbsp;the&nbsp;highest&nbsp;index&nbsp;in&nbsp;S&nbsp;where&nbsp;substring&nbsp;sub&nbsp;is&nbsp;found,<br>
such&nbsp;that&nbsp;sub&nbsp;is&nbsp;contained&nbsp;within&nbsp;S[start:end].&nbsp;&nbsp;Optional<br>
arguments&nbsp;start&nbsp;and&nbsp;end&nbsp;are&nbsp;interpreted&nbsp;as&nbsp;in&nbsp;slice&nbsp;notation.<br>
&nbsp;<br>
Raises&nbsp;ValueError&nbsp;when&nbsp;the&nbsp;substring&nbsp;is&nbsp;not&nbsp;found.</tt></dd></dl>

<dl><dt><a name="IStr-rjust"><strong>rjust</strong></a>(self, width, fillchar=' ', /)</dt><dd><tt>Return&nbsp;a&nbsp;right-justified&nbsp;string&nbsp;of&nbsp;length&nbsp;width.<br>
&nbsp;<br>
Padding&nbsp;is&nbsp;done&nbsp;using&nbsp;the&nbsp;specified&nbsp;fill&nbsp;character&nbsp;(default&nbsp;is&nbsp;a&nbsp;space).</tt></dd></dl>

<dl><dt><a name="IStr-rpartition"><strong>rpartition</strong></a>(self, sep, /)</dt><dd><tt>Partition&nbsp;the&nbsp;string&nbsp;into&nbsp;three&nbsp;parts&nbsp;using&nbsp;the&nbsp;given&nbsp;separator.<br>
&nbsp;<br>
This&nbsp;will&nbsp;search&nbsp;for&nbsp;the&nbsp;separator&nbsp;in&nbsp;the&nbsp;string,&nbsp;starting&nbsp;at&nbsp;the&nbsp;end.&nbsp;If<br>
the&nbsp;separator&nbsp;is&nbsp;found,&nbsp;returns&nbsp;a&nbsp;3-tuple&nbsp;containing&nbsp;the&nbsp;part&nbsp;before&nbsp;the<br>
separator,&nbsp;the&nbsp;separator&nbsp;itself,&nbsp;and&nbsp;the&nbsp;part&nbsp;after&nbsp;it.<br>
&nbsp;<br>
If&nbsp;the&nbsp;separator&nbsp;is&nbsp;not&nbsp;found,&nbsp;returns&nbsp;a&nbsp;3-tuple&nbsp;containing&nbsp;two&nbsp;empty&nbsp;strings<br>
and&nbsp;the&nbsp;original&nbsp;string.</tt></dd></dl>

<dl><dt><a name="IStr-rsplit"><strong>rsplit</strong></a>(self, /, sep=None, maxsplit=-1)</dt><dd><tt>Return&nbsp;a&nbsp;list&nbsp;of&nbsp;the&nbsp;substrings&nbsp;in&nbsp;the&nbsp;string,&nbsp;using&nbsp;sep&nbsp;as&nbsp;the&nbsp;separator&nbsp;string.<br>
&nbsp;<br>
&nbsp;&nbsp;sep<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;separator&nbsp;used&nbsp;to&nbsp;split&nbsp;the&nbsp;string.<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;When&nbsp;set&nbsp;to&nbsp;None&nbsp;(the&nbsp;default&nbsp;value),&nbsp;will&nbsp;split&nbsp;on&nbsp;any&nbsp;whitespace<br>
&nbsp;&nbsp;&nbsp;&nbsp;character&nbsp;(including&nbsp;\\n&nbsp;\\r&nbsp;\\t&nbsp;\\f&nbsp;and&nbsp;spaces)&nbsp;and&nbsp;will&nbsp;discard<br>
&nbsp;&nbsp;&nbsp;&nbsp;empty&nbsp;strings&nbsp;from&nbsp;the&nbsp;result.<br>
&nbsp;&nbsp;maxsplit<br>
&nbsp;&nbsp;&nbsp;&nbsp;Maximum&nbsp;number&nbsp;of&nbsp;splits&nbsp;(starting&nbsp;from&nbsp;the&nbsp;left).<br>
&nbsp;&nbsp;&nbsp;&nbsp;-1&nbsp;(the&nbsp;default&nbsp;value)&nbsp;means&nbsp;no&nbsp;limit.<br>
&nbsp;<br>
Splitting&nbsp;starts&nbsp;at&nbsp;the&nbsp;end&nbsp;of&nbsp;the&nbsp;string&nbsp;and&nbsp;works&nbsp;to&nbsp;the&nbsp;front.</tt></dd></dl>

<dl><dt><a name="IStr-rstrip"><strong>rstrip</strong></a>(self, chars=None, /)</dt><dd><tt>Return&nbsp;a&nbsp;copy&nbsp;of&nbsp;the&nbsp;string&nbsp;with&nbsp;trailing&nbsp;whitespace&nbsp;removed.<br>
&nbsp;<br>
If&nbsp;chars&nbsp;is&nbsp;given&nbsp;and&nbsp;not&nbsp;None,&nbsp;remove&nbsp;characters&nbsp;in&nbsp;chars&nbsp;instead.</tt></dd></dl>

<dl><dt><a name="IStr-split"><strong>split</strong></a>(self, /, sep=None, maxsplit=-1)</dt><dd><tt>Return&nbsp;a&nbsp;list&nbsp;of&nbsp;the&nbsp;substrings&nbsp;in&nbsp;the&nbsp;string,&nbsp;using&nbsp;sep&nbsp;as&nbsp;the&nbsp;separator&nbsp;string.<br>
&nbsp;<br>
&nbsp;&nbsp;sep<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;separator&nbsp;used&nbsp;to&nbsp;split&nbsp;the&nbsp;string.<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;When&nbsp;set&nbsp;to&nbsp;None&nbsp;(the&nbsp;default&nbsp;value),&nbsp;will&nbsp;split&nbsp;on&nbsp;any&nbsp;whitespace<br>
&nbsp;&nbsp;&nbsp;&nbsp;character&nbsp;(including&nbsp;\\n&nbsp;\\r&nbsp;\\t&nbsp;\\f&nbsp;and&nbsp;spaces)&nbsp;and&nbsp;will&nbsp;discard<br>
&nbsp;&nbsp;&nbsp;&nbsp;empty&nbsp;strings&nbsp;from&nbsp;the&nbsp;result.<br>
&nbsp;&nbsp;maxsplit<br>
&nbsp;&nbsp;&nbsp;&nbsp;Maximum&nbsp;number&nbsp;of&nbsp;splits&nbsp;(starting&nbsp;from&nbsp;the&nbsp;left).<br>
&nbsp;&nbsp;&nbsp;&nbsp;-1&nbsp;(the&nbsp;default&nbsp;value)&nbsp;means&nbsp;no&nbsp;limit.<br>
&nbsp;<br>
Note,&nbsp;<a href="builtins.html#str">str</a>.<a href="#IStr-split">split</a>()&nbsp;is&nbsp;mainly&nbsp;useful&nbsp;for&nbsp;data&nbsp;that&nbsp;has&nbsp;been&nbsp;intentionally<br>
delimited.&nbsp;&nbsp;With&nbsp;natural&nbsp;text&nbsp;that&nbsp;includes&nbsp;punctuation,&nbsp;consider&nbsp;using<br>
the&nbsp;regular&nbsp;expression&nbsp;module.</tt></dd></dl>

<dl><dt><a name="IStr-splitlines"><strong>splitlines</strong></a>(self, /, keepends=False)</dt><dd><tt>Return&nbsp;a&nbsp;list&nbsp;of&nbsp;the&nbsp;lines&nbsp;in&nbsp;the&nbsp;string,&nbsp;breaking&nbsp;at&nbsp;line&nbsp;boundaries.<br>
&nbsp;<br>
Line&nbsp;breaks&nbsp;are&nbsp;not&nbsp;included&nbsp;in&nbsp;the&nbsp;resulting&nbsp;list&nbsp;unless&nbsp;keepends&nbsp;is&nbsp;given&nbsp;and<br>
true.</tt></dd></dl>

<dl><dt><a name="IStr-startswith"><strong>startswith</strong></a>(...)</dt><dd><tt>S.<a href="#IStr-startswith">startswith</a>(prefix[,&nbsp;start[,&nbsp;end]])&nbsp;-&gt;&nbsp;bool<br>
&nbsp;<br>
Return&nbsp;True&nbsp;if&nbsp;S&nbsp;starts&nbsp;with&nbsp;the&nbsp;specified&nbsp;prefix,&nbsp;False&nbsp;otherwise.<br>
With&nbsp;optional&nbsp;start,&nbsp;test&nbsp;S&nbsp;beginning&nbsp;at&nbsp;that&nbsp;position.<br>
With&nbsp;optional&nbsp;end,&nbsp;stop&nbsp;comparing&nbsp;S&nbsp;at&nbsp;that&nbsp;position.<br>
prefix&nbsp;can&nbsp;also&nbsp;be&nbsp;a&nbsp;tuple&nbsp;of&nbsp;strings&nbsp;to&nbsp;try.</tt></dd></dl>

<dl><dt><a name="IStr-strip"><strong>strip</strong></a>(self, chars=None, /)</dt><dd><tt>Return&nbsp;a&nbsp;copy&nbsp;of&nbsp;the&nbsp;string&nbsp;with&nbsp;leading&nbsp;and&nbsp;trailing&nbsp;whitespace&nbsp;removed.<br>
&nbsp;<br>
If&nbsp;chars&nbsp;is&nbsp;given&nbsp;and&nbsp;not&nbsp;None,&nbsp;remove&nbsp;characters&nbsp;in&nbsp;chars&nbsp;instead.</tt></dd></dl>

<dl><dt><a name="IStr-swapcase"><strong>swapcase</strong></a>(self, /)</dt><dd><tt>Convert&nbsp;uppercase&nbsp;characters&nbsp;to&nbsp;lowercase&nbsp;and&nbsp;lowercase&nbsp;characters&nbsp;to&nbsp;uppercase.</tt></dd></dl>

<dl><dt><a name="IStr-title"><strong>title</strong></a>(self, /)</dt><dd><tt>Return&nbsp;a&nbsp;version&nbsp;of&nbsp;the&nbsp;string&nbsp;where&nbsp;each&nbsp;word&nbsp;is&nbsp;titlecased.<br>
&nbsp;<br>
More&nbsp;specifically,&nbsp;words&nbsp;start&nbsp;with&nbsp;uppercased&nbsp;characters&nbsp;and&nbsp;all&nbsp;remaining<br>
cased&nbsp;characters&nbsp;have&nbsp;lower&nbsp;case.</tt></dd></dl>

<dl><dt><a name="IStr-translate"><strong>translate</strong></a>(self, table, /)</dt><dd><tt>Replace&nbsp;each&nbsp;character&nbsp;in&nbsp;the&nbsp;string&nbsp;using&nbsp;the&nbsp;given&nbsp;translation&nbsp;table.<br>
&nbsp;<br>
&nbsp;&nbsp;table<br>
&nbsp;&nbsp;&nbsp;&nbsp;Translation&nbsp;table,&nbsp;which&nbsp;must&nbsp;be&nbsp;a&nbsp;mapping&nbsp;of&nbsp;Unicode&nbsp;ordinals&nbsp;to<br>
&nbsp;&nbsp;&nbsp;&nbsp;Unicode&nbsp;ordinals,&nbsp;strings,&nbsp;or&nbsp;None.<br>
&nbsp;<br>
The&nbsp;table&nbsp;must&nbsp;implement&nbsp;lookup/indexing&nbsp;via&nbsp;__getitem__,&nbsp;for&nbsp;instance&nbsp;a<br>
dictionary&nbsp;or&nbsp;list.&nbsp;&nbsp;If&nbsp;this&nbsp;operation&nbsp;raises&nbsp;LookupError,&nbsp;the&nbsp;character&nbsp;is<br>
left&nbsp;untouched.&nbsp;&nbsp;Characters&nbsp;mapped&nbsp;to&nbsp;None&nbsp;are&nbsp;deleted.</tt></dd></dl>

<dl><dt><a name="IStr-upper"><strong>upper</strong></a>(self, /)</dt><dd><tt>Return&nbsp;a&nbsp;copy&nbsp;of&nbsp;the&nbsp;string&nbsp;converted&nbsp;to&nbsp;uppercase.</tt></dd></dl>

<dl><dt><a name="IStr-zfill"><strong>zfill</strong></a>(self, width, /)</dt><dd><tt>Pad&nbsp;a&nbsp;numeric&nbsp;string&nbsp;with&nbsp;zeros&nbsp;on&nbsp;the&nbsp;left,&nbsp;to&nbsp;fill&nbsp;a&nbsp;field&nbsp;of&nbsp;the&nbsp;given&nbsp;width.<br>
&nbsp;<br>
The&nbsp;string&nbsp;is&nbsp;never&nbsp;truncated.</tt></dd></dl>

<hr>
Static methods inherited from <a href="builtins.html#str">builtins.str</a>:<br>
<dl><dt><a name="IStr-__new__"><strong>__new__</strong></a>(*args, **kwargs)<font color="#909090"><font face="helvetica, arial"> from <a href="builtins.html#type">builtins.type</a></font></font></dt><dd><tt>Create&nbsp;and&nbsp;return&nbsp;a&nbsp;new&nbsp;<a href="builtins.html#object">object</a>.&nbsp;&nbsp;See&nbsp;help(type)&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="IStr-maketrans"><strong>maketrans</strong></a>(...)</dt><dd><tt>Return&nbsp;a&nbsp;translation&nbsp;table&nbsp;usable&nbsp;for&nbsp;<a href="builtins.html#str">str</a>.<a href="#IStr-translate">translate</a>().<br>
&nbsp;<br>
If&nbsp;there&nbsp;is&nbsp;only&nbsp;one&nbsp;argument,&nbsp;it&nbsp;must&nbsp;be&nbsp;a&nbsp;dictionary&nbsp;mapping&nbsp;Unicode<br>
ordinals&nbsp;(integers)&nbsp;or&nbsp;characters&nbsp;to&nbsp;Unicode&nbsp;ordinals,&nbsp;strings&nbsp;or&nbsp;None.<br>
Character&nbsp;keys&nbsp;will&nbsp;be&nbsp;then&nbsp;converted&nbsp;to&nbsp;ordinals.<br>
If&nbsp;there&nbsp;are&nbsp;two&nbsp;arguments,&nbsp;they&nbsp;must&nbsp;be&nbsp;strings&nbsp;of&nbsp;equal&nbsp;length,&nbsp;and<br>
in&nbsp;the&nbsp;resulting&nbsp;dictionary,&nbsp;each&nbsp;character&nbsp;in&nbsp;x&nbsp;will&nbsp;be&nbsp;mapped&nbsp;to&nbsp;the<br>
character&nbsp;at&nbsp;the&nbsp;same&nbsp;position&nbsp;in&nbsp;y.&nbsp;If&nbsp;there&nbsp;is&nbsp;a&nbsp;third&nbsp;argument,&nbsp;it<br>
must&nbsp;be&nbsp;a&nbsp;string,&nbsp;whose&nbsp;characters&nbsp;will&nbsp;be&nbsp;mapped&nbsp;to&nbsp;None&nbsp;in&nbsp;the&nbsp;result.</tt></dd></dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Lines">class <strong>Lines</strong></a>(<a href="builtins.html#object">builtins.object</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#Lines">Lines</a>(buffers:&nbsp;'list[<a href="builtins.html#str">str</a>]'&nbsp;=&nbsp;None)<br>
&nbsp;<br>
A&nbsp;list&nbsp;of&nbsp;<a href="builtins.html#str">str</a>&nbsp;that&nbsp;can&nbsp;be&nbsp;serialized&nbsp;to&nbsp;string&nbsp;with&nbsp;provided&nbsp;indents<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="Lines-__add__"><strong>__add__</strong></a>(self, other: 'str')</dt><dd><tt>TODO:&nbsp;depreciate,&nbsp;unintuiative</tt></dd></dl>

<dl><dt><a name="Lines-__delitem__"><strong>__delitem__</strong></a>(self, key: 'int')</dt></dl>

<dl><dt><a name="Lines-__getitem__"><strong>__getitem__</strong></a>(self, key: 'int')</dt></dl>

<dl><dt><a name="Lines-__init__"><strong>__init__</strong></a>(self, buffers: 'list[str]' = None)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="Lines-__len__"><strong>__len__</strong></a>(self)</dt></dl>

<dl><dt><a name="Lines-__repr__"><strong>__repr__</strong></a>(self)</dt><dd><tt>Return&nbsp;repr(self).</tt></dd></dl>

<dl><dt><a name="Lines-__rshift__"><strong>__rshift__</strong></a>(self, indent: 'int')</dt></dl>

<dl><dt><a name="Lines-__setitem__"><strong>__setitem__</strong></a>(self, key: 'int', value: 'str')</dt></dl>

<dl><dt><a name="Lines-__str__"><strong>__str__</strong></a>(self)</dt><dd><tt>Return&nbsp;<a href="builtins.html#str">str</a>(self).</tt></dd></dl>

<dl><dt><a name="Lines-add"><strong>add</strong></a>(self, string: 'str')</dt></dl>

<dl><dt><a name="Lines-concat"><strong>concat</strong></a>(self, other: 'Lines', indent: 'int' = 0)</dt></dl>

<dl><dt><a name="Lines-toString"><strong>toString</strong></a>(self, indent: 'int' = 0)</dt></dl>

<hr>
Static methods defined here:<br>
<dl><dt><a name="Lines-nestify"><strong>nestify</strong></a>(buffers: 'list[tuple[Lines][Lines]]', indent: 'int' = 0)</dt><dd><tt>pair[0][0]<br>
&nbsp;&nbsp;&nbsp;&nbsp;pair[1][0]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pair[2][0]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pair[2][1]<br>
&nbsp;&nbsp;&nbsp;&nbsp;pair[1][0]<br>
pair[0][1]</tt></dd></dl>

<hr>
Data descriptors defined here:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table></td></tr></table><p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#eeaa77">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Functions</strong></big></font></td></tr>
    
<tr><td bgcolor="#eeaa77"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><dl><dt><a name="-buffer_indentify"><strong>buffer_indentify</strong></a>(indent: 'int' = 0, buffers: 'list[str]' = []) -&gt; 'str'</dt><dd><tt>Serializes&nbsp;a&nbsp;list&nbsp;of&nbsp;strings&nbsp;with&nbsp;indents<br>
Note:&nbsp;depreciated&nbsp;by&nbsp;<a href="#Lines">Lines</a>&nbsp;class<br>
TODO:&nbsp;remove&nbsp;uses&nbsp;and&nbsp;delete&nbsp;function</tt></dd></dl>
 <dl><dt><a name="-indentify"><strong>indentify</strong></a>(indent: 'int' = 0, text: 'str' = '') -&gt; 'str'</dt><dd><tt>Indents&nbsp;a&nbsp;string</tt></dd></dl>
</td></tr></table><p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#55aa55">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Data</strong></big></font></td></tr>
    
<tr><td bgcolor="#55aa55"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><strong>__all__</strong> = ['GeneratorParser', 'Lines', 'DoubleBufferBuffer', 'indentify', 'buffer_indentify', 'IStr']</td></tr></table>
</body></html>